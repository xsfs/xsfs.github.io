<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>创建者模式 | 心随风散</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">创建者模式</h1><a id="logo" href="/.">心随风散</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">创建者模式</h1><div class="post-meta"><a href="/2019/08/31/创建者模式/#comments" class="comment-count"></a><p><span class="date">Aug 31, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。<br>创建型模式分为以下几种。  </p>
<ol>
<li><a href="https://www.xsfs.xyz/2019/08/31/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_self"><strong>单例（Singleton）模式</strong>:</a>某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li><a href="https://www.xsfs.xyz/2019/08/31/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F" target="_self"><strong>原型（Prototype）模式</strong>:</a>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li><a href="https://www.xsfs.xyz/2019/08/31/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F" target="_self"><strong>工厂方法（FactoryMethod）模式</strong>:</a>定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li><a href="https://www.xsfs.xyz/2019/08/31/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" target="_self"><strong>抽象工厂（AbstractFactory）模式</strong>:</a>提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li><a href="https://www.xsfs.xyz/2019/08/31/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F" target="_self"><strong>建造者（Builder）模式</strong>:</a>将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
</ol>
<p>以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式，我们将在之后的教程中详细地介绍它们的特点、结构与应用。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>单例（Singleton）模式的定义：</strong>指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。<br>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成例。  </p>
<p><strong>单例模式有 3 个特点：</strong></p>
<ol>
<li>单例类只有一个实例对象；</li>
<li>该单例对象必须由单例类自行创建；</li>
<li>单例类对外提供一个访问该单例的全局访问点；</li>
</ol>
<p><strong>单例模式的结构与实现</strong><br>单例模式是设计模式中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p>
<p><strong>单例模式的结构</strong><br>单例模式的主要角色如下。<br>单例类：包含一个实例且能自行创建这个实例的类。<br>访问类：使用单例的类。<br>其结构如图 1 所示。  </p>
<p><img src="/images/pasted-10.png" alt="upload successful"></p>
<center>图1 单例模式的结构图</center>

<p><strong>单例模式的实现</strong><br>Singleton 模式通常有两种实现形式。<br>第 1 种：懒汉式单例<br>该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。<br>第 2 种：饿汉式单例<br>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。  </p>
<p><strong>单例模式的应用场景</strong><br>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。<br>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。   </p>
<p><strong>单例模式的扩展</strong><br>单例模式可扩展为有限的多例（Multitcm）模式，这种模式可生成有限个实例并保存在 ArmyList 中，客户需要时可随机获取，其结构图如图2所示。</p>
<p><img src="/images/pasted-11.png" alt="upload successful"></p>
<center>图2 有限的多例模式的结构图</center>

<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p><strong>原型（Prototype）模式</strong>的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。  </p>
<p><strong>原型模式的结构</strong><br>原型模式包含以下主要角色。<br>抽象原型类：规定了具体原型对象必须实现的接口。<br>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。<br>访问类：使用具体原型类中的 clone() 方法来复制新的对象。<br>其结构图如图3所示。  </p>
<p><img src="/images/pasted-12.png" alt="upload successful"></p>
<center>图3 原型模式的结构图</center>

<p><strong>原型模式的扩展</strong><br>原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。其结构图如图4所示。</p>
<p><img src="/images/pasted-13.png" alt="upload successful"></p>
<center>图4 带原型管理器的原型模式的结构图</center>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><strong>工厂方法（FactoryMethod）模式</strong>的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。<br>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。  </p>
<p><strong>工厂方法模式的主要优点</strong>有：</p>
<ol>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li>
</ol>
<p><strong>其缺点</strong>是：<br>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p>
<p><strong>模式的结构</strong><br>工厂方法模式的主要角色如下。<br>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。<br>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。<br>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。<br>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。<br>其结构图如图5所示。</p>
<p><img src="/images/pasted-14.png" alt="upload successful"></p>
<center>图5 工厂模式结构图</center>

<p><strong>模式的应用场景</strong><br>工厂方法模式通常适用于以下场景。<br>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。<br>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。<br>客户不关心创建产品的细节，只关心产品的品牌。  </p>
<p><strong>模式的扩展</strong><br>当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式，其结构图如图 6 所示。</p>
<p><img src="/images/pasted-15.png" alt="upload successful"></p>
<center>图6 简单工厂模式的结构图</center>

<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><strong>抽象工厂（AbstractFactory）模式的定义：</strong>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。<br>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。  </p>
<p>使用抽象工厂模式一般要满足以下条件。  </p>
<ol>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>
</ol>
<p>抽象工厂模式除了具有工厂方法模式的<strong>优点</strong>外，其他主要优点如下。  </p>
<ol>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
<li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</li>
</ol>
<p>其<strong>缺点</strong>是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。 </p>
<p><strong>模式的结构</strong><br>抽象工厂模式的主要角色如下。<br>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。<br>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。<br>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。<br>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。<br>抽象工厂模式的结构图如图 7 所示。  </p>
<p><img src="/images/pasted-16.png" alt="upload successful"></p>
<center>图7 抽象工厂模式的结构图</center>

<p><strong>模式的应用场景</strong><br>抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 java 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。<br>抽象工厂模式通常适用于以下场景：<br>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。<br>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。<br>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。  </p>
<p><strong>模式的扩展</strong><br>抽象工厂模式的扩展有一定的“开闭原则”倾斜性：</p>
<ol>
<li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。  </li>
<li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。  </li>
<li>另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。   </li>
</ol>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p><strong>建造者（Builder）模式的定义：</strong>指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
<p><strong>该模式的主要优点</strong>如下：</p>
<ol>
<li>各个具体的建造者相互独立，有利于系统的扩展。</li>
<li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li>
</ol>
<p>其<strong>缺点</strong>如下：</p>
<ol start="2">
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，该模式会增加很多的建造者类。</li>
</ol>
<p><strong>模式的结构</strong><br>建造者（Builder）模式的主要角色如下。<br>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。<br>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。<br>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。<br>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。<br>其结构图如图 8 所示。</p>
<p><img src="/images/pasted-17.png" alt="upload successful"></p>
<center>图8 建造者模式的结构图</center>

<p><strong>模式的应用场景</strong><br>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。<br>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。<br>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。  </p>
<p><strong>模式的扩展</strong><br>建造者（Builder）模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉抽象建造者，甚至可以省略掉指挥者角色。</p>
</div><div class="post-copyright"><blockquote><p>这里本来是声明作者和版权的地方</p><p>但是这个是我平时学习记录的文字，写原文作者和版权不太合适</p><p>所以，放上我最喜欢的一句话：起风了，唯有努力生存。</p><!--p=  __("copyright_author") + ": " + config.author--><!--p= __("copyright_link") + ": "--><!--  a(href=url_for(config.url +'/'+ page.path))= config.url +'/'+ page.path--><!--p!= __("copyright_notice") + ": " + (theme.copyright.describe ? theme.copyright.describe : __("copyright_details"))--></blockquote></div><div class="tags"><a href="/tags/设计模式/">设计模式</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/09/02/confluence使用/" class="pre">confluence使用</a><a href="/2019/08/31/设计模式/" class="next">设计模式</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#创建型模式"><span class="toc-text">创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式"><span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型模式"><span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工厂方法模式"><span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象工厂模式"><span class="toc-text">抽象工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建造者模式"><span class="toc-text">建造者模式</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/03/hexo提交/">hexo提交</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/03/idea-git操作/">idea git操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/03/功能测试点/">功能测试点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/02/Mysql的增删改查/">Mysql的增删改查</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/02/confluence使用/">confluence使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/31/创建者模式/">创建者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/31/设计模式/">设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/31/常用Terminal命令/">常用Terminal命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/UML/">UML</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/19/test/test/">README</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/readme/" style="font-size: 15px;">readme</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/常用/" style="font-size: 15px;">常用</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/UML/" style="font-size: 15px;">UML</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">心随.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>